import os
import json
from pathlib import Path
from typing import Dict, Any, List
from schema.project import ProjectSpec
from pydantic import ValidationError


class Architect:
    """
    架构师类，负责根据JSON规格说明物理落地文件和目录
    遵循目录隔离原则，业务代码必须存在于 output/项目名/src 目录下
    """
    
    def __init__(self, base_output_dir: str = "output"):
        self.base_output_dir = Path(base_output_dir)
        
    def create_project_structure(self, project_spec: Dict[str, Any]) -> bool:
        """
        根据项目规格创建项目结构
        遵循目录隔离原则，确保业务代码存在于指定目录
        """
        try:
            # 验证项目规格
            spec = ProjectSpec(**project_spec)
        except ValidationError as e:
            print(f"项目规格验证失败: {e}")
            return False

        # 创建项目根目录
        project_root = self.base_output_dir / spec.project_name
        project_root.mkdir(parents=True, exist_ok=True)

        # 创建标准目录结构
        dirs_to_create = [
            project_root / "src",
            project_root / "tests",
            project_root / "docs",
            project_root / "config",
            project_root / "scripts"
        ]

        for dir_path in dirs_to_create:
            dir_path.mkdir(exist_ok=True)

        # 创建 README.md
        readme_path = project_root / "README.md"

        # 生成技术债章节
        tech_debt_section = "\n## 技术债\n\n以下是在 flexible 路径下可能存在的重构风险：\n\n"
        for task in spec.tasks:
            if task.flexibility == "flexible":
                tech_debt_section += f"- **{task.title}**: 由于采用灵活实现路径，未来可能需要重构以提升性能或标准化实现方式\n"

        if tech_debt_section == "\n## 技术债\n\n以下是在 flexible 路径下可能存在的重构风险：\n\n":
            tech_debt_section = "\n## 技术债\n\n该项目中没有使用 flexible 路径的任务，因此没有相关的重构风险。\n"

        readme_content = f"# {spec.project_name}\n\n{spec.description}\n\n## 项目结构\n\n此项目由 Vibe Nexus 框架自动生成。\n{tech_debt_section}"
        readme_path.write_text(readme_content, encoding='utf-8')

        # 创建架构提案文档 (TECH_PROPOSAL.md)
        tech_proposal_path = project_root / "TECH_PROPOSAL.md"
        tech_proposal_content = f"# {spec.project_name} - 技术方案白皮书\n\n{spec.architecture_proposal}\n\n## 项目任务技术要求\n\n"
        for task in spec.tasks:
            tech_proposal_content += f"\n### 任务: {task.title}\n"
            tech_proposal_content += f"**技术要求**: {task.technical_requirement}\n"
            tech_proposal_content += f"**目标路径**: {task.target_path}\n"
            tech_proposal_content += f"**验证标准**: {task.verification}\n"
            tech_proposal_content += f"**灵活性**: {task.flexibility}\n"
        tech_proposal_path.write_text(tech_proposal_content, encoding='utf-8')

        # 创建开发日志 (DEVELOPMENT_LOG.md)
        dev_log_path = project_root / "DEVELOPMENT_LOG.md"
        dev_log_content = f"# {spec.project_name} - 开发日志\n\n## 设计意图留言板\n\n此文件记录了所有任务的初始设计意图，供下游Agent参考。\n\n"
        for task in spec.tasks:
            dev_log_content += f"\n### 任务: {task.title}\n"
            dev_log_content += f"- **描述**: {task.description}\n"
            dev_log_content += f"- **目标路径**: {task.target_path}\n"
            dev_log_content += f"- **灵活性**: {task.flexibility}\n"
            dev_log_content += f"- **技术要求**: {task.technical_requirement}\n"
            dev_log_content += f"- **验证标准**: {task.verification}\n\n"
        dev_log_path.write_text(dev_log_content, encoding='utf-8')

        # 创建项目配置文件 - 保存完整的项目规格，包括所有任务，供Coder读取
        config_path = project_root / "config" / "project.json"
        # 使用model_dump()方法获取完整的规格数据，包括所有任务
        full_spec_dict = spec.model_dump()
        config_path.write_text(json.dumps(full_spec_dict, ensure_ascii=False, indent=2), encoding='utf-8')

        # 生成环境设置脚本
        self._create_setup_scripts(project_root)

        # 根据任务列表创建文件和目录
        for task in spec.tasks:
            success = self._create_task_artifacts(task, project_root)
            if not success:
                print(f"创建任务 {task.id} 的产物失败: {task.title}")
                return False

        print(f"项目 {spec.project_name} 结构创建成功！")
        return True

    def _create_setup_scripts(self, project_root: Path):
        """
        生成环境设置脚本，包括 requirements.txt 和环境配置脚本
        """
        # 创建 requirements.txt
        requirements_path = project_root / "requirements.txt"
        requirements_content = """# Project Dependencies
# Generated by Vibe Nexus Framework

# Core dependencies
python-dotenv>=1.0.0
pydantic>=2.0.0
aiohttp>=3.8.0

# Testing
pytest>=7.0.0
pytest-asyncio>=0.21.0

# Development
black>=23.0.0
flake8>=6.0.0
"""
        requirements_path.write_text(requirements_content, encoding='utf-8')

        # 创建 setup_env.sh (Linux/MacOS)
        setup_sh_path = project_root / "setup_env.sh"
        setup_sh_content = f'''#!/bin/bash
# Environment Setup Script for {project_root.name}
# Generated by Vibe Nexus Framework

set -e  # Exit on any error

echo "Setting up environment for {project_root.name}..."

# Create virtual environment if it doesn\\'t exist
if [ ! -d "venv" ]; then
    echo "Creating virtual environment..."
    python -m venv venv
fi

# Activate virtual environment
source venv/bin/activate

# Upgrade pip
pip install --upgrade pip

# Install dependencies
echo "Installing dependencies..."
pip install -r requirements.txt

# Set PYTHONPATH
export PYTHONPATH="$(pwd):$PYTHONPATH"

echo "Environment setup complete!"
echo "Virtual environment activated."
echo "Dependencies installed."
echo "PYTHONPATH set to $(pwd)"

# Instructions
echo ""
echo "To activate this environment in future sessions:"
echo "  source venv/bin/activate"
echo "  export PYTHONPATH=\\"$(pwd):$PYTHONPATH\\""
'''
        setup_sh_path.write_text(setup_sh_content, encoding='utf-8')

        # 使shell脚本可执行
        import stat
        setup_sh_path.chmod(stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)

        # 创建 setup_env.bat (Windows)
        setup_bat_path = project_root / "setup_env.bat"
        setup_bat_content = f'''@echo off
REM Environment Setup Script for {project_root.name}
REM Generated by Vibe Nexus Framework

echo Setting up environment for {project_root.name}...

REM Create virtual environment if it doesn't exist
if not exist "venv" (
    echo Creating virtual environment...
    python -m venv venv
)

REM Activate virtual environment
call venv\\Scripts\\activate.bat

REM Upgrade pip
python -m pip install --upgrade pip

REM Install dependencies
echo Installing dependencies...
pip install -r requirements.txt

REM Set PYTHONPATH
set PYTHONPATH=%cd%;%PYTHONPATH%

echo Environment setup complete!
echo Virtual environment activated.
echo Dependencies installed.
echo PYTHONPATH set to %%cd%%

REM Instructions
echo.
echo To activate this environment in future sessions:
echo   venv\\Scripts\\activate.bat
echo   set PYTHONPATH=%%cd%%;%%PYTHONPATH%%
'''
        setup_bat_path.write_text(setup_bat_content, encoding='utf-8')

        print(f"环境设置脚本已生成: {project_root.name}")
    
    def _create_task_artifacts(self, task: 'Task', project_root: Path) -> bool:
        """
        根据任务创建对应的文件和目录
        遵循PnC准则，每个任务都有物理路径和验证步骤
        """
        try:
            # 解析目标路径 - 修复路径处理问题，规范化路径分隔符
            normalized_target_path = task.target_path.replace('\\', '/').replace('//', '/')
            # 修复路径中包含空格的问题
            target_path = project_root / normalized_target_path.lstrip('/')

            # 确保项目根目录存在
            project_root.mkdir(parents=True, exist_ok=True)
            
            # 如果目标路径以 / 结尾，表示是目录
            if normalized_target_path.endswith('/'):
                target_path.mkdir(parents=True, exist_ok=True)
            else:
                # 否则是文件，创建父目录并写入内容
                target_path.parent.mkdir(parents=True, exist_ok=True)
                
                # 根据文件扩展名生成默认内容
                if target_path.suffix.lower() in ['.py', '.js', '.ts', '.jsx', '.tsx']:
                    content = self._generate_default_code_content(task, target_path.suffix)
                elif target_path.suffix.lower() == '.md':
                    content = self._generate_default_markdown_content(task)
                elif target_path.suffix.lower() in ['.json', '.yaml', '.yml']:
                    content = self._generate_default_config_content(task)
                else:
                    content = self._generate_default_generic_content(task)
                    
                target_path.write_text(content, encoding='utf-8')
                
            # 创建验证脚本（如果适用）
            self._create_verification_script(task, project_root)
            
            # 为src目录下的任务强制创建测试占位
            if normalized_target_path.startswith('src/') and normalized_target_path.endswith(('.py', '.js', '.ts')):
                self._create_test_placeholder(task, project_root)
                
            return True
        except PermissionError as e:
            print(f"权限错误，无法创建任务产物 {task.id} ({task.title}): {str(e)}")
            print(f"  尝试的路径: {target_path}")
            print(f"  项目根目录: {project_root}")
            print(f"  提示: 可能是路径中包含特殊字符或权限不足")
            return False
        except FileNotFoundError as e:
            print(f"路径错误，无法创建任务产物 {task.id} ({task.title}): {str(e)}")
            print(f"  尝试的路径: {target_path}")
            print(f"  项目根目录: {project_root}")
            print(f"  提示: 可能是路径中包含非法字符或路径太深")
            return False
        except Exception as e:
            print(f"创建任务产物失败 {task.id} ({task.title}): {str(e)}")
            print(f"  尝试的路径: {target_path}")
            print(f"  项目根目录: {project_root}")
            return False

    def _create_test_placeholder(self, task: 'Task', project_root: Path):
        """
        为src目录下的任务强制创建测试占位
        """
        # 生成测试文件名 - 修复路径分隔符问题
        src_path = task.target_path.replace('\\', '/')  # 标准化路径分隔符
        if src_path.startswith('src/'):
            relative_path = src_path[4:]  # 移除 'src/' 前缀
        else:
            relative_path = src_path

        # 生成测试文件路径 - 修复路径处理问题
        test_dir = project_root / "tests"
        
        # 修复文件名生成逻辑，防止路径中出现非法字符
        # 将路径中的斜杠替换为下划线，但保留文件扩展名
        path_parts = relative_path.split('/')
        if len(path_parts) > 1:  # 有子目录
            dir_parts = path_parts[:-1]  # 目录部分
            file_part = path_parts[-1]  # 文件名部分
            clean_path_parts = [part.replace('.', '_') for part in dir_parts]  # 目录部分替换点为下划线
        else:  # 没有子目录，只有文件
            dir_parts = []
            file_part = path_parts[0] if path_parts else ""
            clean_path_parts = []
        
        if file_part:  # 如果有文件名
            if '.' in file_part:
                name_part, ext_part = file_part.rsplit('.', 1)
                clean_file_name = f"test_{name_part}_{ext_part}.py" if ext_part == 'py' else f"test_{name_part}_{ext_part}.js" if ext_part in ['js', 'ts'] else f"test_{name_part}_{ext_part}.py"
            else:
                clean_file_name = f"test_{file_part}.py"
        else:
            clean_file_name = "test_unnamed.py"
            
        # 构建完整的测试文件路径
        if clean_path_parts:  # 如果有子目录
            # 如果有子目录，创建对应的测试子目录结构
            test_subdir = test_dir.joinpath(*clean_path_parts)
            test_file_path = test_subdir / clean_file_name
            test_subdir.mkdir(parents=True, exist_ok=True)
        else:
            test_file_path = test_dir / clean_file_name
            test_dir.mkdir(parents=True, exist_ok=True)

        # 生成测试内容，将verification内容填入Docstring，并根据verification内容生成对应的测试函数名
        if relative_path.endswith('.py'):
            # 根据verification内容生成测试函数名
            import re
            # 提取verification中的关键信息用于生成测试函数名
            verification_lower = task.verification.lower()

            # 检查是否包含pytest相关关键词
            has_pytest = 'pytest' in verification_lower or 'test' in verification_lower

            # 生成测试函数名
            if 'can run' in verification_lower or 'able to run' in verification_lower:
                test_method_name = "test_can_run_successfully"
            elif 'respond' in verification_lower or 'response' in verification_lower:
                test_method_name = "test_responds_correctly"
            elif 'handle' in verification_lower:
                test_method_name = "test_handles_correctly"
            elif 'work' in verification_lower:
                test_method_name = "test_works_as_expected"
            elif 'error' in verification_lower or 'exception' in verification_lower:
                test_method_name = "test_error_handling"
            elif 'connection' in verification_lower:
                test_method_name = "test_connection_established"
            elif 'process' in verification_lower:
                test_method_name = "test_processes_correctly"
            else:
                # 使用通用名称
                clean_title = re.sub(r'[^a-zA-Z0-9_]', '_', task.title.replace(" ", "_"))
                test_method_name = f"test_{clean_title.lower()}_implementation"

            test_content = f'''"""
Test for {task.title}

Task Description: {task.description}
Verification Criteria: {task.verification}
Technical Requirement: {task.technical_requirement}
Flexibility: {task.flexibility}
"""
import unittest


class Test{task.title.replace(" ", "").replace("-", "")}(unittest.TestCase):
    """Test class for {task.title}"""

    def {test_method_name}(self):
        """Test that {task.title} meets verification criteria: {task.verification}"""
        # TODO: Implement test based on verification criteria
        # Task: {task.description}
        # Technical Requirement: {task.technical_requirement}
        # Flexibility: {task.flexibility}
        self.assertTrue(True)  # Replace with actual test


if __name__ == "__main__":
    unittest.main()
'''
        else:  # For JS/TS or other files
            test_content = f'''/**
 * Test for {task.title}
 *
 * Task Description: {task.description}
 * Verification Criteria: {task.verification}
 * Technical Requirement: {task.technical_requirement}
 * Flexibility: {task.flexibility}
 */

// TODO: Implement test based on verification criteria
// Task: {task.description}
// Technical Requirement: {task.technical_requirement}
// Flexibility: {task.flexibility}

console.log("Test placeholder for {task.title}");
'''

        test_file_path.write_text(test_content, encoding='utf-8')
    
    def _generate_default_code_content(self, task: 'Task', extension: str) -> str:
        """
        为代码文件生成默认内容
        """
        if extension == '.py':
            # 根据technical_requirement中的关键词生成相应代码片段
            code_snippets = []

            # 检查是否需要线程锁
            if 'threading.RLock' in task.technical_requirement or 'RLock' in task.technical_requirement or 'lock' in task.technical_requirement.lower():
                code_snippets.append('import threading\n\nlock = threading.RLock()\n')

            # 检查是否需要接口或类定义
            if 'interface' in task.technical_requirement.lower() or 'abstract' in task.technical_requirement.lower():
                code_snippets.append('from abc import ABC, abstractmethod\n\n')

            # 检查是否需要异常处理
            if 'exception' in task.technical_requirement.lower() or 'error handling' in task.technical_requirement.lower():
                code_snippets.append('# 异常处理将在实现中添加\n')

            # 检查是否需要特定的数据结构
            if 'queue' in task.technical_requirement.lower():
                code_snippets.append('from queue import Queue\n')
            elif 'dict' in task.technical_requirement.lower() or 'dictionary' in task.technical_requirement.lower():
                code_snippets.append('# 使用字典作为数据结构\n')

            snippets_str = '\n'.join(code_snippets) if code_snippets else ''

            # 根据是否需要接口来构建类定义
            if 'interface' in task.technical_requirement.lower():
                # 构建接口类定义
                class_lines = [
                    f'class {task.title.replace(" ", "").replace("-", "")}(ABC):',
                    f'    """{task.title} implementation class"""',
                    f'    ',
                    f'    def __init__(self):',
                    f'        """Initialize {task.title}"""',
                    f'        pass',
                    f'    ',
                    f'    @abstractmethod',
                    f'    def execute(self):',
                    f'        """Execute the main functionality"""'
                ]

                # 添加锁相关的代码
                if 'threading.RLock' in task.technical_requirement or 'RLock' in task.technical_requirement or 'lock' in task.technical_requirement.lower():
                    class_lines.extend([
                        f'        with lock:',
                        f'            # TODO: 实现 {task.title}',
                        f'            # {task.description}',
                        f'            # Technical Requirement: {task.technical_requirement}',
                        f'            pass'
                    ])
                else:
                    class_lines.extend([
                        f'        # TODO: 实现 {task.title}',
                        f'        # {task.description}',
                        f'        # Technical Requirement: {task.technical_requirement}',
                        f'        pass'
                    ])

                class_def = '\n'.join(class_lines)
            else:
                # 构建普通类定义
                class_lines = [
                    f'class {task.title.replace(" ", "").replace("-", "")}():',
                    f'    """{task.title} implementation class"""',
                    f'    ',
                    f'    def __init__(self):',
                    f'        """Initialize {task.title}"""',
                    f'        pass',
                    f'    ',
                    f'    def execute(self):',
                    f'        """Execute the main functionality"""'
                ]

                # 添加锁相关的代码
                if 'threading.RLock' in task.technical_requirement or 'RLock' in task.technical_requirement or 'lock' in task.technical_requirement.lower():
                    class_lines.extend([
                        f'        with lock:',
                        f'            # TODO: 实现 {task.title}',
                        f'            # {task.description}',
                        f'            # Technical Requirement: {task.technical_requirement}',
                        f'            pass'
                    ])
                else:
                    class_lines.extend([
                        f'        # TODO: 实现 {task.title}',
                        f'        # {task.description}',
                        f'        # Technical Requirement: {task.technical_requirement}',
                        f'        pass'
                    ])

                class_def = '\n'.join(class_lines)

            # 构建完整的文件内容
            content_parts = [
                f'"""',
                f'{task.title}',
                f'',
                f'Description: {task.description}',
                f'Technical Requirement: {task.technical_requirement}',
                f'"""',
                snippets_str,
                '',
                class_def,
                '',
                f'def main():',
                f'    # TODO: 实现 {task.title}',
                f'    # {task.description}',
                f'    # Technical Requirement: {task.technical_requirement}',
                f'    pass',
                f'',
                f'if __name__ == "__main__":',
                f'    main()'
            ]
            return '\n'.join(content_parts)
        elif extension == '.java':
            # Java代码生成
            return f'''/**
 * {task.title}
 *
 * Description: {task.description}
 * Technical Requirement: {task.technical_requirement}
 */
public class {task.title.replace(" ", "").replace("-", "")} {{

    // TODO: 实现 {task.title}
    // {task.description}
    // Technical Requirement: {task.technical_requirement}

    public {task.title.replace(" ", "").replace("-", "")}() {{
        // Constructor implementation
    }}

    public void execute() {{
        // Implementation goes here
    }}
}}
'''
        elif extension in ['.js', '.ts', '.jsx', '.tsx']:
            return f'''/**
 * {task.title}
 *
 * Description: {task.description}
 * Technical Requirement: {task.technical_requirement}
 */

// TODO: 实现 {task.title}
// {task.description}
// Technical Requirement: {task.technical_requirement}

export const {task.title.replace(" ", "").replace("-", "_")} = () => {{
    // Implementation goes here
}};
'''
        else:
            return f"# {task.title}\n# Description: {task.description}\n# Technical Requirement: {task.technical_requirement}\n\n"
    
    def _generate_default_markdown_content(self, task: 'Task') -> str:
        """
        为Markdown文件生成默认内容
        """
        return f"""# {task.title}

## 描述
{task.description}

## 实现细节
TODO: 添加实现细节

## 验证步骤
{task.verification}
"""
    
    def _generate_default_config_content(self, task: 'Task') -> str:
        """
        为配置文件生成默认内容
        """
        return json.dumps({"task_id": task.id, "title": task.title, "description": task.description}, 
                         ensure_ascii=False, indent=2)
    
    def _generate_default_generic_content(self, task: 'Task') -> str:
        """
        为通用文件生成默认内容
        """
        return f"{task.title}\n\n{task.description}\n\nVerification: {task.verification}\n"
    
    def _create_verification_script(self, task: 'Task', project_root: Path):
        """
        为任务创建验证脚本
        """
        # 创建测试文件用于验证
        if task.target_path.endswith(('.py', '.js', '.ts')):
            test_dir = project_root / "tests"
            test_dir.mkdir(exist_ok=True)
            
            # 生成测试文件名
            test_file_name = f"test_{task.target_path.split('/')[-1].replace('.', '_').replace('-', '_')}"
            test_file_path = test_dir / f"{test_file_name}.py"
            
            test_content = f'''"""
测试 {task.title}
验证步骤: {task.verification}
"""
import unittest


class Test{task.title.replace(" ", "").replace("-", "")}(unittest.TestCase):
    def test_implementation(self):
        """验证 {task.title} 是否按预期工作"""
        # TODO: 根据验证步骤 {task.verification} 编写测试
        self.assertTrue(True)  # 替换为实际测试


if __name__ == "__main__":
    unittest.main()
'''
            test_file_path.write_text(test_content, encoding='utf-8')